use crate::endpoint::{Endpoint};
use crate::resource_id::{ResourceId};
use crate::poll::{PollRegister};
use crate::adapter::{ActionHandler, EventHandler};
use crate::util::{SendingStatus, OTHER_THREAD_ERR};

use mio::event::{Source};

use std::collections::{HashMap};
use std::net::{SocketAddr};
use std::sync::{Arc, RwLock};
use std::io::{self};

/// Struct used to pack the events generated by the adapter.
/// The upper layer will traduce this event into a [crate::network::NetEvent]
/// that the user can manage.
pub enum AdapterEvent<'a> {
    Added,
    Data(&'a [u8]),
    Removed,
}

pub struct ResourceRegister<S> {
    // We store the local addr because if the resource disconnects, it can not be retrieved.
    resources: RwLock<HashMap<ResourceId, (S, SocketAddr)>>,
    poll_register: PollRegister,
}

impl<S: Source> ResourceRegister<S> {
    pub fn new(poll_register: PollRegister) -> ResourceRegister<S> {
        ResourceRegister { resources: RwLock::new(HashMap::new()), poll_register }
    }

    pub fn add(&mut self, mut resource: S, addr: SocketAddr) -> ResourceId {
        let id = self.poll_register.add(&mut resource);
        self.resources.write().expect(OTHER_THREAD_ERR).insert(id, (resource, addr));
        id
    }

    pub fn remove(&mut self, id: ResourceId) -> Option<S> {
        let poll_register = &mut self.poll_register;
        self.resources
            .write()
            .expect(OTHER_THREAD_ERR)
            .remove(&id)
            .map(|(mut resource, _)| {
                poll_register.remove(&mut resource);
                resource
            })
    }

    pub fn read_source(&self, id: ResourceId, mut action: impl FnMut(&S, SocketAddr))
        -> Option<()> {
        let resources = self.resources.read().expect(OTHER_THREAD_ERR);
        resources.get(&id).map(|(resource, addr)| action(resource, *addr))
    }

    pub fn write_source(&mut self, id: ResourceId, mut action: impl FnMut(&S, SocketAddr)) -> Option<()> {
        let mut resources = self.resources.write().expect(OTHER_THREAD_ERR);
        resources.get_mut(&id).map(|(resource, addr)| action(resource, *addr))
    }
}

pub trait ActionController {
    fn connect(&mut self, addr: SocketAddr) -> io::Result<Endpoint>;
    fn listen(&mut self, addr: SocketAddr) -> io::Result<(ResourceId, SocketAddr)>;
    fn send(&mut self, endpoint: Endpoint, data: &[u8]) -> SendingStatus;
    fn remove(&mut self, id: ResourceId) -> Option<()>;
    fn local_addr(&self, id: ResourceId) -> Option<SocketAddr>;
}

pub struct GenericActionController<R, L> {
    remote_register: Arc<ResourceRegister<R>>,
    listener_register: Arc<ResourceRegister<L>>,
    action_handler: Box<dyn ActionHandler<Remote=R, Listener=L>>,
}

impl<R: Source, L: Source> GenericActionController<R, L> {
    pub fn new(
        remote_register: Arc<ResourceRegister<R>>,
        listener_register: Arc<ResourceRegister<L>>,
        action_handler: impl ActionHandler<Remote=R, Listener=L> + 'static,
    ) -> GenericActionController<R, L> {
        GenericActionController {
            remote_register,
            listener_register,
            action_handler: Box::new(action_handler),
        }
    }
}

impl<R: Source, L: Source> ActionController for GenericActionController<R, L> {
    fn connect(&mut self, addr: SocketAddr) -> io::Result<Endpoint> {
        todo!()
    }

    fn listen(&mut self, addr: SocketAddr) -> io::Result<(ResourceId, SocketAddr)> {
        todo!()
    }

    fn send(&mut self, endpoint: Endpoint, data: &[u8]) -> SendingStatus {
        todo!()
    }

    fn remove(&mut self, id: ResourceId) -> Option<()> {
        todo!()
        /*
        let poll_register = &mut self.poll_register;
        match id.resource_type() {
            ResourceType::Listener => self
                .store
                .listeners
                .write()
                .expect(OTHER_THREAD_ERR)
                .remove(&id)
                .map(|mut listener| poll_register.remove(&mut listener)),
            ResourceType::Remote => self
                .store
                .sockets
                .write()
                .expect(OTHER_THREAD_ERR)
                .remove(&id)
                .map(|(mut socket, _)| {
                    Self::leave_multicast_v4(&mut socket);
                    poll_register.remove(&mut socket)
                }),
        }
        */
    }

    fn local_addr(&self, id: ResourceId) -> Option<SocketAddr> {
        todo!()
        /*
        match id.resource_type() {
            ResourceType::Listener => self
                .store
                .listeners
                .read()
                .expect(OTHER_THREAD_ERR)
                .get(&id)
                .map(|listener| listener.local_addr().unwrap()),
            ResourceType::Remote => self
                .store
                .sockets
                .read()
                .expect(OTHER_THREAD_ERR)
                .get(&id)
                .map(|(socket, _)| socket.local_addr().unwrap()),
        }
        */
    }
}

pub trait EventProcessor<C>
where C: FnMut(Endpoint, AdapterEvent<'_>) {
    fn process(&mut self, id: ResourceId, event_callback: &mut C);
}

pub struct GenericEventProcessor<R, L> {
    remote_register: Arc<ResourceRegister<R>>,
    listener_register: Arc<ResourceRegister<L>>,
    event_handler: Box<dyn EventHandler<Remote=R, Listener=L>>,
}

impl<R: Source, L: Source> GenericEventProcessor<R, L> {
    pub fn new(
        remote_register: Arc<ResourceRegister<R>>,
        listener_register: Arc<ResourceRegister<L>>,
        event_handler: impl EventHandler<Remote=R, Listener=L> + 'static,
    ) -> GenericEventProcessor<R, L> {
        GenericEventProcessor {
            remote_register,
            listener_register,
            event_handler: Box::new(event_handler),
        }
    }
}

impl<C, R: Source, L: Source> EventProcessor<C> for GenericEventProcessor<R, L>
where C: FnMut(Endpoint, AdapterEvent<'_>) {
    fn process(&mut self, id: ResourceId, event_callback: &mut C) {
        todo!()
    }
}

